// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package usecases

import (
	"context"
	"sync"

	"github.com/PiskarevSA/minimarket-auth/internal/domain/entities"
	"github.com/PiskarevSA/minimarket-auth/internal/domain/objects"
	"github.com/PiskarevSA/minimarket-auth/internal/events"
	"github.com/google/uuid"
)

// Ensure that mockAccountRepo does implement accountRepo.
// If this is not the case, regenerate this file with mockery.
var _ accountRepo = &mockAccountRepo{}

// mockAccountRepo is a mock implementation of accountRepo.
//
//	func TestSomethingThatUsesaccountRepo(t *testing.T) {
//
//		// make and configure a mocked accountRepo
//		mockedaccountRepo := &mockAccountRepo{
//			CreateAccountInTxFunc: func(ctx context.Context, account entities.Account) error {
//				panic("mock out the CreateAccountInTx method")
//			},
//			GetUserIdAndPasswordHashFunc: func(ctx context.Context, login objects.Login) (uuid.UUID, []byte, error) {
//				panic("mock out the GetUserIdAndPasswordHash method")
//			},
//		}
//
//		// use mockedaccountRepo in code that requires accountRepo
//		// and then make assertions.
//
//	}
type mockAccountRepo struct {
	// CreateAccountInTxFunc mocks the CreateAccountInTx method.
	CreateAccountInTxFunc func(ctx context.Context, account entities.Account) error

	// GetUserIdAndPasswordHashFunc mocks the GetUserIdAndPasswordHash method.
	GetUserIdAndPasswordHashFunc func(ctx context.Context, login objects.Login) (uuid.UUID, []byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateAccountInTx holds details about calls to the CreateAccountInTx method.
		CreateAccountInTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Account is the account argument value.
			Account entities.Account
		}
		// GetUserIdAndPasswordHash holds details about calls to the GetUserIdAndPasswordHash method.
		GetUserIdAndPasswordHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Login is the login argument value.
			Login objects.Login
		}
	}
	lockCreateAccountInTx        sync.RWMutex
	lockGetUserIdAndPasswordHash sync.RWMutex
}

// CreateAccountInTx calls CreateAccountInTxFunc.
func (mock *mockAccountRepo) CreateAccountInTx(ctx context.Context, account entities.Account) error {
	if mock.CreateAccountInTxFunc == nil {
		panic("mockAccountRepo.CreateAccountInTxFunc: method is nil but accountRepo.CreateAccountInTx was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Account entities.Account
	}{
		Ctx:     ctx,
		Account: account,
	}
	mock.lockCreateAccountInTx.Lock()
	mock.calls.CreateAccountInTx = append(mock.calls.CreateAccountInTx, callInfo)
	mock.lockCreateAccountInTx.Unlock()
	return mock.CreateAccountInTxFunc(ctx, account)
}

// CreateAccountInTxCalls gets all the calls that were made to CreateAccountInTx.
// Check the length with:
//
//	len(mockedaccountRepo.CreateAccountInTxCalls())
func (mock *mockAccountRepo) CreateAccountInTxCalls() []struct {
	Ctx     context.Context
	Account entities.Account
} {
	var calls []struct {
		Ctx     context.Context
		Account entities.Account
	}
	mock.lockCreateAccountInTx.RLock()
	calls = mock.calls.CreateAccountInTx
	mock.lockCreateAccountInTx.RUnlock()
	return calls
}

// GetUserIdAndPasswordHash calls GetUserIdAndPasswordHashFunc.
func (mock *mockAccountRepo) GetUserIdAndPasswordHash(ctx context.Context, login objects.Login) (uuid.UUID, []byte, error) {
	if mock.GetUserIdAndPasswordHashFunc == nil {
		panic("mockAccountRepo.GetUserIdAndPasswordHashFunc: method is nil but accountRepo.GetUserIdAndPasswordHash was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Login objects.Login
	}{
		Ctx:   ctx,
		Login: login,
	}
	mock.lockGetUserIdAndPasswordHash.Lock()
	mock.calls.GetUserIdAndPasswordHash = append(mock.calls.GetUserIdAndPasswordHash, callInfo)
	mock.lockGetUserIdAndPasswordHash.Unlock()
	return mock.GetUserIdAndPasswordHashFunc(ctx, login)
}

// GetUserIdAndPasswordHashCalls gets all the calls that were made to GetUserIdAndPasswordHash.
// Check the length with:
//
//	len(mockedaccountRepo.GetUserIdAndPasswordHashCalls())
func (mock *mockAccountRepo) GetUserIdAndPasswordHashCalls() []struct {
	Ctx   context.Context
	Login objects.Login
} {
	var calls []struct {
		Ctx   context.Context
		Login objects.Login
	}
	mock.lockGetUserIdAndPasswordHash.RLock()
	calls = mock.calls.GetUserIdAndPasswordHash
	mock.lockGetUserIdAndPasswordHash.RUnlock()
	return calls
}

// Ensure that mockOutboxRepo does implement outboxRepo.
// If this is not the case, regenerate this file with mockery.
var _ outboxRepo = &mockOutboxRepo{}

// mockOutboxRepo is a mock implementation of outboxRepo.
//
//	func TestSomethingThatUsesoutboxRepo(t *testing.T) {
//
//		// make and configure a mocked outboxRepo
//		mockedoutboxRepo := &mockOutboxRepo{
//			CreateOutboxInTxFunc: func(ctx context.Context, event events.Event) error {
//				panic("mock out the CreateOutboxInTx method")
//			},
//		}
//
//		// use mockedoutboxRepo in code that requires outboxRepo
//		// and then make assertions.
//
//	}
type mockOutboxRepo struct {
	// CreateOutboxInTxFunc mocks the CreateOutboxInTx method.
	CreateOutboxInTxFunc func(ctx context.Context, event events.Event) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateOutboxInTx holds details about calls to the CreateOutboxInTx method.
		CreateOutboxInTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event events.Event
		}
	}
	lockCreateOutboxInTx sync.RWMutex
}

// CreateOutboxInTx calls CreateOutboxInTxFunc.
func (mock *mockOutboxRepo) CreateOutboxInTx(ctx context.Context, event events.Event) error {
	if mock.CreateOutboxInTxFunc == nil {
		panic("mockOutboxRepo.CreateOutboxInTxFunc: method is nil but outboxRepo.CreateOutboxInTx was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event events.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockCreateOutboxInTx.Lock()
	mock.calls.CreateOutboxInTx = append(mock.calls.CreateOutboxInTx, callInfo)
	mock.lockCreateOutboxInTx.Unlock()
	return mock.CreateOutboxInTxFunc(ctx, event)
}

// CreateOutboxInTxCalls gets all the calls that were made to CreateOutboxInTx.
// Check the length with:
//
//	len(mockedoutboxRepo.CreateOutboxInTxCalls())
func (mock *mockOutboxRepo) CreateOutboxInTxCalls() []struct {
	Ctx   context.Context
	Event events.Event
} {
	var calls []struct {
		Ctx   context.Context
		Event events.Event
	}
	mock.lockCreateOutboxInTx.RLock()
	calls = mock.calls.CreateOutboxInTx
	mock.lockCreateOutboxInTx.RUnlock()
	return calls
}
